[
    {
        "question": "Theo quy trình cấp Chứng nhận trường mầm non đạt kiểm định chất lượng giáo dục, thành phần hồ sơ bắt buộc gồm những tài liệu nào?",
        "right_answer": "B",
        "model_output": "C\n",
        "extracted_output": "C",
        "extract_answer_code": "    def extract_answer_letter(self, text: str, num_choices: int) -> str:\n        \"\"\"Extract answer letter from model output based on number of choices\n        \n        Args:\n            text: Model output text\n            num_choices: Number of choices (e.g., 4 for A-D, 5 for A-E, etc.)\n            \n        Returns:\n            Extracted answer letter or empty string if not found\n        \"\"\"\n        # Generate valid letters dynamically based on num_choices\n        max_letter = chr(65 + num_choices - 1)  # 65 is ASCII for 'A'\n        valid_pattern = f\"[A-{max_letter}]\"\n        \n        # Try to find answer in format \"Answer: X\" or \"Đáp án: X\"\n        patterns = [\n            rf\"(?:Answer|Đáp án|answer|đáp án)\\s*[:：]\\s*({valid_pattern})\",\n            rf\"\\b({valid_pattern})\\b(?:\\s*[.)]|\\s*$)\",  # Single letter\n            rf\"^\\s*({valid_pattern})\\s*[.)]\",  # Letter at start with dot or parenthesis\n        ]\n        \n        for pattern in patterns:\n            match = re.search(pattern, text, re.IGNORECASE)\n            if match:\n                return match.group(1).upper()\n        \n        # If no pattern matches, look for last occurrence of valid letters\n        matches = re.findall(rf'\\b({valid_pattern})\\b', text, re.IGNORECASE)\n        if matches:\n            return matches[-1].upper()\n        \n        return \"\"\n"
    },
    {
        "question": "Công thức hoá học của oxit có thành phần phần trăm của S là 40%:",
        "right_answer": "B",
        "model_output": "A\n",
        "extracted_output": "A",
        "extract_answer_code": "    def extract_answer_letter(self, text: str, num_choices: int) -> str:\n        \"\"\"Extract answer letter from model output based on number of choices\n        \n        Args:\n            text: Model output text\n            num_choices: Number of choices (e.g., 4 for A-D, 5 for A-E, etc.)\n            \n        Returns:\n            Extracted answer letter or empty string if not found\n        \"\"\"\n        # Generate valid letters dynamically based on num_choices\n        max_letter = chr(65 + num_choices - 1)  # 65 is ASCII for 'A'\n        valid_pattern = f\"[A-{max_letter}]\"\n        \n        # Try to find answer in format \"Answer: X\" or \"Đáp án: X\"\n        patterns = [\n            rf\"(?:Answer|Đáp án|answer|đáp án)\\s*[:：]\\s*({valid_pattern})\",\n            rf\"\\b({valid_pattern})\\b(?:\\s*[.)]|\\s*$)\",  # Single letter\n            rf\"^\\s*({valid_pattern})\\s*[.)]\",  # Letter at start with dot or parenthesis\n        ]\n        \n        for pattern in patterns:\n            match = re.search(pattern, text, re.IGNORECASE)\n            if match:\n                return match.group(1).upper()\n        \n        # If no pattern matches, look for last occurrence of valid letters\n        matches = re.findall(rf'\\b({valid_pattern})\\b', text, re.IGNORECASE)\n        if matches:\n            return matches[-1].upper()\n        \n        return \"\"\n"
    },
    {
        "question": "Ngôi chùa Ba La Mật được khai dựng vào năm nào?",
        "right_answer": "A",
        "model_output": "C\n",
        "extracted_output": "C",
        "extract_answer_code": "    def extract_answer_letter(self, text: str, num_choices: int) -> str:\n        \"\"\"Extract answer letter from model output based on number of choices\n        \n        Args:\n            text: Model output text\n            num_choices: Number of choices (e.g., 4 for A-D, 5 for A-E, etc.)\n            \n        Returns:\n            Extracted answer letter or empty string if not found\n        \"\"\"\n        # Generate valid letters dynamically based on num_choices\n        max_letter = chr(65 + num_choices - 1)  # 65 is ASCII for 'A'\n        valid_pattern = f\"[A-{max_letter}]\"\n        \n        # Try to find answer in format \"Answer: X\" or \"Đáp án: X\"\n        patterns = [\n            rf\"(?:Answer|Đáp án|answer|đáp án)\\s*[:：]\\s*({valid_pattern})\",\n            rf\"\\b({valid_pattern})\\b(?:\\s*[.)]|\\s*$)\",  # Single letter\n            rf\"^\\s*({valid_pattern})\\s*[.)]\",  # Letter at start with dot or parenthesis\n        ]\n        \n        for pattern in patterns:\n            match = re.search(pattern, text, re.IGNORECASE)\n            if match:\n                return match.group(1).upper()\n        \n        # If no pattern matches, look for last occurrence of valid letters\n        matches = re.findall(rf'\\b({valid_pattern})\\b', text, re.IGNORECASE)\n        if matches:\n            return matches[-1].upper()\n        \n        return \"\"\n"
    },
    {
        "question": "Theo thông tin được cung cấp, tỉnh nào sau đây đã được sáp nhập vào tỉnh Gia Lai để hình thành tỉnh Gia Lai hiện tại?",
        "right_answer": "A",
        "model_output": "B\n",
        "extracted_output": "B",
        "extract_answer_code": "    def extract_answer_letter(self, text: str, num_choices: int) -> str:\n        \"\"\"Extract answer letter from model output based on number of choices\n        \n        Args:\n            text: Model output text\n            num_choices: Number of choices (e.g., 4 for A-D, 5 for A-E, etc.)\n            \n        Returns:\n            Extracted answer letter or empty string if not found\n        \"\"\"\n        # Generate valid letters dynamically based on num_choices\n        max_letter = chr(65 + num_choices - 1)  # 65 is ASCII for 'A'\n        valid_pattern = f\"[A-{max_letter}]\"\n        \n        # Try to find answer in format \"Answer: X\" or \"Đáp án: X\"\n        patterns = [\n            rf\"(?:Answer|Đáp án|answer|đáp án)\\s*[:：]\\s*({valid_pattern})\",\n            rf\"\\b({valid_pattern})\\b(?:\\s*[.)]|\\s*$)\",  # Single letter\n            rf\"^\\s*({valid_pattern})\\s*[.)]\",  # Letter at start with dot or parenthesis\n        ]\n        \n        for pattern in patterns:\n            match = re.search(pattern, text, re.IGNORECASE)\n            if match:\n                return match.group(1).upper()\n        \n        # If no pattern matches, look for last occurrence of valid letters\n        matches = re.findall(rf'\\b({valid_pattern})\\b', text, re.IGNORECASE)\n        if matches:\n            return matches[-1].upper()\n        \n        return \"\"\n"
    },
    {
        "question": "Cuộc thi người mẫu nào tổ chức quy mô toàn quốc phải có giấy phép của ai?",
        "right_answer": "A",
        "model_output": "B. Bộ Văn hóa, Thể thao và Du lịch\n",
        "extracted_output": "B",
        "extract_answer_code": "    def extract_answer_letter(self, text: str, num_choices: int) -> str:\n        \"\"\"Extract answer letter from model output based on number of choices\n        \n        Args:\n            text: Model output text\n            num_choices: Number of choices (e.g., 4 for A-D, 5 for A-E, etc.)\n            \n        Returns:\n            Extracted answer letter or empty string if not found\n        \"\"\"\n        # Generate valid letters dynamically based on num_choices\n        max_letter = chr(65 + num_choices - 1)  # 65 is ASCII for 'A'\n        valid_pattern = f\"[A-{max_letter}]\"\n        \n        # Try to find answer in format \"Answer: X\" or \"Đáp án: X\"\n        patterns = [\n            rf\"(?:Answer|Đáp án|answer|đáp án)\\s*[:：]\\s*({valid_pattern})\",\n            rf\"\\b({valid_pattern})\\b(?:\\s*[.)]|\\s*$)\",  # Single letter\n            rf\"^\\s*({valid_pattern})\\s*[.)]\",  # Letter at start with dot or parenthesis\n        ]\n        \n        for pattern in patterns:\n            match = re.search(pattern, text, re.IGNORECASE)\n            if match:\n                return match.group(1).upper()\n        \n        # If no pattern matches, look for last occurrence of valid letters\n        matches = re.findall(rf'\\b({valid_pattern})\\b', text, re.IGNORECASE)\n        if matches:\n            return matches[-1].upper()\n        \n        return \"\"\n"
    },
    {
        "question": "Một công ty đang xem xét việc đầu tư vào một dòng sản phẩm mới. Lợi nhuận kỳ vọng trên vốn đầu tư là 15%, nhưng có khả năng 20% dòng sản phẩm này sẽ thất bại và dẫn đến mức lỗ 10%. Giá trị kỳ vọng của khoản đầu tư này là bao nhiêu?",
        "right_answer": "D",
        "model_output": "A. 13%\n",
        "extracted_output": "A",
        "extract_answer_code": "    def extract_answer_letter(self, text: str, num_choices: int) -> str:\n        \"\"\"Extract answer letter from model output based on number of choices\n        \n        Args:\n            text: Model output text\n            num_choices: Number of choices (e.g., 4 for A-D, 5 for A-E, etc.)\n            \n        Returns:\n            Extracted answer letter or empty string if not found\n        \"\"\"\n        # Generate valid letters dynamically based on num_choices\n        max_letter = chr(65 + num_choices - 1)  # 65 is ASCII for 'A'\n        valid_pattern = f\"[A-{max_letter}]\"\n        \n        # Try to find answer in format \"Answer: X\" or \"Đáp án: X\"\n        patterns = [\n            rf\"(?:Answer|Đáp án|answer|đáp án)\\s*[:：]\\s*({valid_pattern})\",\n            rf\"\\b({valid_pattern})\\b(?:\\s*[.)]|\\s*$)\",  # Single letter\n            rf\"^\\s*({valid_pattern})\\s*[.)]\",  # Letter at start with dot or parenthesis\n        ]\n        \n        for pattern in patterns:\n            match = re.search(pattern, text, re.IGNORECASE)\n            if match:\n                return match.group(1).upper()\n        \n        # If no pattern matches, look for last occurrence of valid letters\n        matches = re.findall(rf'\\b({valid_pattern})\\b', text, re.IGNORECASE)\n        if matches:\n            return matches[-1].upper()\n        \n        return \"\"\n"
    },
    {
        "question": "Đoạn thông tin:\n[1] Tiêu đề: Cuba\nNội dung: II. Chính trị\n2. Liên đoàn thương mại\n\nCó các liên đoàn kinh tế tại Cuba, với số thành viên lên tới 98% nhân lực hòn đảo này. Các liên đoàn không đăng ký với bất kỳ một cơ quan nhà nước nào, và tự lấy kinh phí hoạt động từ nguồn đóng góp thành viên hàng tháng. Những người ủng hộ họ cho rằng các viên chức liên đoàn được bầu lên trên cơ sở tự do, và có nhiều quan điểm chính trị bên trong mỗi liên đoàn. Tuy nhiên, tất cả các liên đoàn đều là một phần của một tổ chức được gọi là Confederación de Trabajadores Cubanos (Hiệp hội Công nhân Cuba, CTC), hội này thực sự có những mối quan hệ mật thiết với nhà nước và Đảng Cộng sản. Những người ủng hộ cho rằng CTC cho phép công nhân chuyển ý kiến lên chính phủ; những người đối lập lại cho rằng chính phủ sử dụng nó để kiểm soát các công đoàn thương mại và chỉ định các thành viên lãnh đạo công đoàn. Quyền tự do bày tỏ ý kiến của công nhân cũng là một vấn đề được tranh luận. Những người ủng hộ hệ thống cho rằng những ý kiến của công nhân trên thực tế đã hình thành nên chính sách của chính phủ trong nhiều hoàn cảnh, như đề xuất cải cách thuế năm 1993, trong khi phe đối lập, đưa ra những nghiên cứu của các tổ chức lao động quốc tế cho thấy công nhân bị buộc phải thề nguyền trung thành với các lý tưởng của Đảng Cộng sản, và cho rằng chính phủ chi phối một cách có hệ thống và cản trở các nhà hoạt động công đoàn, trong khi vẫn ngăn cấm việc thành lập các liên đoàn thương mại độc lập (không thuộc CTC), rằng các lãnh đạo các liên đoàn độc lập đã bị bỏ tù, và rằng quyền đình công của công nhân không được ghi nhận trong luật.\n\n3. Quan hệ đối ngoại\n\n3.1. Việt Nam\n\nQuan hệ ngoại giao giữa hai nước vô cùng đặc biệt. Ngày 12 tháng 9 năm 1973, Fidel Castro là vị nguyên thủ nước ngoài đầu tiên và duy nhất thăm vùng giải phóng miền Nam khi chiến tranh chưa kết thúc. Cũng trong chuyến thăm lần đầu tiên này, Cuba đã tặng Việt Nam 5 công trình kinh tế - xã hội với tổng trị giá khoảng 80 triệu USD bao gồm: khách sạn Thắng Lợi (Hồ Tây, Hà Nội), Bệnh viện Việt Nam - Cuba (Đồng Hới, Quảng Bình), đường Xuân Mai, trại bò giống Ba Vì, Xí nghiệp gà Lương Mỹ; tặng bò giống, gà giống và chi hơn 6 triệu USD để mua thiết bị hiện đại, đồng thời cử chuyên gia về cầu đường sang Việt Nam tham gia cùng bộ đội Trường Sơn mở rộng Đường Trường Sơn, và giúp đào tạo trên 1.000 sinh viên Việt Nam ở trình độ đại học và cao học...Cuba là nước Mỹ Latinh đầu tiên và cũng là một trong những nước sớm nhất trên thế giới công nhận chính thức Mặt trận Dân tộc Giải phóng miền Nam Việt Nam. Cơ quan đại diện thường trú của Mặt trận Dân tộc Giải phóng miền Nam Việt Nam tại La Habana (Ban đầu tòa đại sứ này đặt tạm tại một biệt thự ở khu phố lao động Kohly, nhưng sau được Chính phủ Cuba cấp thêm một biệt thự sân vườn rất lớn tại Quinta Avenida, đại lộ số 5 dài nhất và đẹp nhất thủ đô La Habana) được hưởng đầy đủ quy chế ngoại giao. Sau khi Chính phủ Cách mạng lâm thời Cộng hòa Miền Nam Việt Nam thành lập, cơ quan này nhanh chóng được chuyển thành đại sứ quán miền Nam Việt Nam. Thời chiến khốc liệt, thông cảm hoàn cảnh khó khăn của nước bạn, Thủ tướng Fidel Castro bao cấp toàn phần. Tất cả từ nhà cửa, xe cộ, trang thiết bị làm việc, ăn ở, chi phí ngoại giao, kể cả lương bổng, phụ cấp của cán bộ, nhân viên sứ quán đều được Cuba bảo đảm chu đáo.Sau Sự kiện 30 tháng 4 năm 1975, hầu hết các nước đều dừng viện trợ không hoàn lại cho Việt Nam, riêng Cuba là một trong số ít các nước tiếp tục viện trợ cho Việt Nam 10 năm tiếp theo từ 1975-1985.\n\n3.2. Mỹ\n\nNgày 17 tháng 12 năm 2014, qua vai trò trung gian của Tòa Thánh Vatican, Chủ tịch Cuba Raul Castro và Tổng thống Hoa Kỳ Barack Obama tuyên bố đã đạt được một thỏa thuận về việc bình thường hóa quan hệ ngoại giao giữa hai nước sau hơn 50 năm gián đoạn. Tuy nhiên, việc bình thường hóa quan hệ còn phải trải qua một giai đoạn dài phía trước vì nó phải nhận được sự phê chuẩn từ lưỡng viện Quốc hội Hoa Kỳ. Tuy nhiên, tổng thống kế nhiệm ông Obama là Donald Trump vào năm 2016 đã hủy bỏ chính sách thân thiện của người tiền nhiệm, và tiếp tục duy trì cấm vận đối với Cuba.\n\nIII. Phân chia hành chính\n\nCuba có ba cấp hành chính là trung ương, tỉnh (provincias) và hạt (municipios). Cấp tỉnh có 14 đơn vị, cấp hạt có 169 đơn vị. Có một hạt đặc biệt, được xếp ngang với cấp tỉnh, đó là Isla de la Juventud. Trước kia Cuba chỉ có sáu tỉnh: Pinar del Río, Habana, Matanzas, Las Villas, Camagüey và Oriente. Cách phân chia hành chính hiện nay rất giống với kiểu tỉnh quân sự Tây Ban Nha trong những cuộc chiến tranh giành độc lập của Cuba, khi hầu hết những vùng có nhiều rắc rối đều được chia nhỏ.\n\nIV. Địa lý\n\nCuba là một quần đảo nằm tại Biển Caribbean, với tọa độ địa lý 21°3N, 80°00W. Cuba là hòn đảo chính, được bao quanh bởi bốn nhóm đảo lớn. Chúng gồm Colorados, Camagüey, Jardines de la Reina và Canarreos. Hòn đảo chính Cuba chiếm hầu hết diện tích đất nước (105.006 km² hay 40.543 dặm vuông) và là hòn đảo lớn thứ 17 trên thế giới theo diện tích. Hòn đảo lớn thứ hai tại Cuba là Đảo Thanh niên (Isla de la Juventud), tên cũ là Đảo Thông (Isla de la Pinos) ở phía đông nam, với diện tích 3056 km² (1180 dặm vuông). Cuba có tổng diện tích đất liền 110.860 km².\nHòn đảo chính gồm chủ yếu các đồng bằng phẳng tới hơi dốc. Ở cực phía đông nam Sierra Maestra, một rặng núi dốc đứng với điểm cao nhất là Pico Real del Turquino 2.005 mét (6.578 ft). Khí hậu địa phương là nhiệt đới, dù được điều tiết ôn hòa bởi gió mậu dịch. Nói chúng (với biến thiên theo địa phương), có một mùa khô từ tháng 11 tới tháng 4, và một mùa mưa từ tháng 5 tới tháng 10. Nhiệt độ trung bình 21 °C vào tháng 1 và 27 °C vào tháng 7. Cuba nằm trên đường đi của các cơn bão và chúng thường xảy ra nhất trong khoảng từ tháng 9 tới tháng 10. La Habana là thành phố lớn nhất và thủ đô Cuba; các thành phố lớn khác gồm Santiago de Cuba và Camagüey. Những thị trấn khác gồm Baracoa từng là khu định cư đầu tiên của người Tây Ban Nha tại Cuba, Trinidad, và một di sản thế giới của UNESCO, and Bayamo.\n\nV. Xã hội\n1. Giáo dục\n\nVề lịch sử, Cuba luôn có tỷ lệ giáo dục và biết chữ cao nhất Mỹ Latinh, cả trước và sau thời kỳ cách mạng. Giáo dục là miễn phí đối với mọi công dân Cuba gồm cả giáo dục đại học. Các định chế giáo dục tư nhân không được phép hoạt động. Phổ cập giáo dục áp dụng với mọi đứa trẻ từ sáu tuổi tới hết mức giáo dục cấp hai căn bản (thường là 15 tuổi) và tất cả học sinh, không cần biết giới tính và sắc tộc, đều mặc đồng phục của trường với màu sắc thể hiện cấp học. Trong suốt quá trình học, học sinh không phải trả một khoản phí nào, từ tiền may đồng phục, tiền mua sắm sách vở, giấy bút và còn được nuôi ăn một bữa hoặc cả ngày (tùy theo từng trường). Do vậy, gần như không có một trẻ em Cuba nào bị thất học, dù đó là ở nơi nông thôn xa xôi.\nGiáo dục tiểu học kéo dài sáu năm, giáo dục trung học cơ sở được chia thành mức căn bản và tiền đại học. Giáo dục cao học được tiến hành tại các trường đại học, các viện, các viện sư phạm và các viện bách khoa. Đại học La Habana được thành lập năm 1728 và có một số trường cao đẳng cũng như đại học khác. Bộ Giáo dục Cao học Cuba cũng điều hành chương trình Giáo dục Từ xa mở các lớp buổi chiều và buổi tối tại các vùng nông thôn cho các lao động nông nghiệp. Giáo dục được đề cao cả về mặt chính trị và ý thức hệ, và sinh viên bậc cao học được chờ đợi sẽ là người thực hiện các mục tiêu do chính phủ Cuba đề ra.\nCâu hỏi: Theo ngữ cảnh, nhận định nào sau đây chính xác về vai trò của Confederación de Trabajadores Cubanos (CTC) trong chính trị Cuba?",
        "right_answer": "B",
        "model_output": "A\n",
        "extracted_output": "A",
        "extract_answer_code": "    def extract_answer_letter(self, text: str, num_choices: int) -> str:\n        \"\"\"Extract answer letter from model output based on number of choices\n        \n        Args:\n            text: Model output text\n            num_choices: Number of choices (e.g., 4 for A-D, 5 for A-E, etc.)\n            \n        Returns:\n            Extracted answer letter or empty string if not found\n        \"\"\"\n        # Generate valid letters dynamically based on num_choices\n        max_letter = chr(65 + num_choices - 1)  # 65 is ASCII for 'A'\n        valid_pattern = f\"[A-{max_letter}]\"\n        \n        # Try to find answer in format \"Answer: X\" or \"Đáp án: X\"\n        patterns = [\n            rf\"(?:Answer|Đáp án|answer|đáp án)\\s*[:：]\\s*({valid_pattern})\",\n            rf\"\\b({valid_pattern})\\b(?:\\s*[.)]|\\s*$)\",  # Single letter\n            rf\"^\\s*({valid_pattern})\\s*[.)]\",  # Letter at start with dot or parenthesis\n        ]\n        \n        for pattern in patterns:\n            match = re.search(pattern, text, re.IGNORECASE)\n            if match:\n                return match.group(1).upper()\n        \n        # If no pattern matches, look for last occurrence of valid letters\n        matches = re.findall(rf'\\b({valid_pattern})\\b', text, re.IGNORECASE)\n        if matches:\n            return matches[-1].upper()\n        \n        return \"\"\n"
    },
    {
        "question": "Trong một nền kinh tế hai hàng hóa, nếu giá của hàng hóa X là 5 đô la và giá của hàng hóa Y là 10 đô la, và người tiêu dùng có thu nhập là 100 đô la, thì độ dốc của đường ngân sách là bao nhiêu?",
        "right_answer": "B",
        "model_output": "A\n",
        "extracted_output": "A",
        "extract_answer_code": "    def extract_answer_letter(self, text: str, num_choices: int) -> str:\n        \"\"\"Extract answer letter from model output based on number of choices\n        \n        Args:\n            text: Model output text\n            num_choices: Number of choices (e.g., 4 for A-D, 5 for A-E, etc.)\n            \n        Returns:\n            Extracted answer letter or empty string if not found\n        \"\"\"\n        # Generate valid letters dynamically based on num_choices\n        max_letter = chr(65 + num_choices - 1)  # 65 is ASCII for 'A'\n        valid_pattern = f\"[A-{max_letter}]\"\n        \n        # Try to find answer in format \"Answer: X\" or \"Đáp án: X\"\n        patterns = [\n            rf\"(?:Answer|Đáp án|answer|đáp án)\\s*[:：]\\s*({valid_pattern})\",\n            rf\"\\b({valid_pattern})\\b(?:\\s*[.)]|\\s*$)\",  # Single letter\n            rf\"^\\s*({valid_pattern})\\s*[.)]\",  # Letter at start with dot or parenthesis\n        ]\n        \n        for pattern in patterns:\n            match = re.search(pattern, text, re.IGNORECASE)\n            if match:\n                return match.group(1).upper()\n        \n        # If no pattern matches, look for last occurrence of valid letters\n        matches = re.findall(rf'\\b({valid_pattern})\\b', text, re.IGNORECASE)\n        if matches:\n            return matches[-1].upper()\n        \n        return \"\"\n"
    },
    {
        "question": "Chủ Tịch Hồ Chí Minh đã tiếp thu những giá trị tích cực nào từ Nho giáo để phục vụ cách mạng?",
        "right_answer": "C",
        "model_output": "B. Lý tưởng xã hội bình trị và đại đồng\nD. Đề cao văn hóa, lễ giáo và truyền thống hiếu học\n\nChủ tịch Hồ Chí Minh đã tiếp thu và vận dụng nhiều giá trị tích cực từ Nho giáo để phục vụ sự nghiệp cách mạng Việt Nam. Trong đó, nổi bật là:\n\n*   **Lý tưởng xã hội bình trị và đại đồng:** Hồ Chí Minh đã kế thừa và phát triển tư tưởng về một xã hội công bằng, bình đẳng, nơi mọi người đều được ấm no, hạnh phúc.\n*   **Đề cao văn hóa, lễ giáo và truyền thống hiếu học:** Hồ Chí Minh luôn coi trọng văn hóa dân tộc, đề cao đạo đức, lễ nghĩa và khuyến khích tinh thần học tập để nâng cao dân trí, phục vụ đất nước.\n\nVì vậy, đáp án chính xác là **B và D**.",
        "extracted_output": "B",
        "extract_answer_code": "    def extract_answer_letter(self, text: str, num_choices: int) -> str:\n        \"\"\"Extract answer letter from model output based on number of choices\n        \n        Args:\n            text: Model output text\n            num_choices: Number of choices (e.g., 4 for A-D, 5 for A-E, etc.)\n            \n        Returns:\n            Extracted answer letter or empty string if not found\n        \"\"\"\n        # Generate valid letters dynamically based on num_choices\n        max_letter = chr(65 + num_choices - 1)  # 65 is ASCII for 'A'\n        valid_pattern = f\"[A-{max_letter}]\"\n        \n        # Try to find answer in format \"Answer: X\" or \"Đáp án: X\"\n        patterns = [\n            rf\"(?:Answer|Đáp án|answer|đáp án)\\s*[:：]\\s*({valid_pattern})\",\n            rf\"\\b({valid_pattern})\\b(?:\\s*[.)]|\\s*$)\",  # Single letter\n            rf\"^\\s*({valid_pattern})\\s*[.)]\",  # Letter at start with dot or parenthesis\n        ]\n        \n        for pattern in patterns:\n            match = re.search(pattern, text, re.IGNORECASE)\n            if match:\n                return match.group(1).upper()\n        \n        # If no pattern matches, look for last occurrence of valid letters\n        matches = re.findall(rf'\\b({valid_pattern})\\b', text, re.IGNORECASE)\n        if matches:\n            return matches[-1].upper()\n        \n        return \"\"\n"
    },
    {
        "question": "Một quả bóng bay hình cầu có bán kính $ R $ đang được bơm phồng. Áp suất bên trong quả bóng tỷ lệ thuận với lực căng bề mặt $ \\sigma $ và tỷ lệ nghịch với bán kính $ R $. Nếu bán kính của quả bóng được nhân đôi, áp suất bên trong quả bóng thay đổi theo nhân tử nào?",
        "right_answer": "B",
        "model_output": "Let $P$ be the pressure inside the balloon, $\\sigma$ be the surface tension, and $R$ be the radius of the balloon.\nWe are given that the pressure inside the balloon is proportional to the surface tension $\\sigma$ and inversely proportional to the radius $R$. This can be written as:\n$$P \\propto \\frac{\\sigma}{R}$$\nSo, we can write the pressure as:\n$$P = k \\frac{\\sigma}{R}$$\nwhere $k$ is a constant of proportionality.\n\nNow, let's consider the case when the radius of the balloon is doubled, i.e., the new radius is $R' = 2R$. We want to find the new pressure $P'$ in terms of the original pressure $P$.\nThe new pressure $P'$ is given by:\n$$P' = k \\frac{\\sigma}{R'} = k \\frac{\\sigma}{2R}$$\nWe can rewrite this as:\n$$P' = \\frac{1}{2} \\left( k \\frac{\\sigma}{R} \\right) = \\frac{1}{2} P$$\nSo, the new pressure $P'$ is half of the original pressure $P$.\nThe pressure inside the balloon changes by a factor of $\\frac{1}{2}$.\n\nThe correct choice is B.\n\nFinal Answer: The final answer is $\\boxed{B}$",
        "extracted_output": "I",
        "extract_answer_code": "    def extract_answer_letter(self, text: str, num_choices: int) -> str:\n        \"\"\"Extract answer letter from model output based on number of choices\n        \n        Args:\n            text: Model output text\n            num_choices: Number of choices (e.g., 4 for A-D, 5 for A-E, etc.)\n            \n        Returns:\n            Extracted answer letter or empty string if not found\n        \"\"\"\n        # Generate valid letters dynamically based on num_choices\n        max_letter = chr(65 + num_choices - 1)  # 65 is ASCII for 'A'\n        valid_pattern = f\"[A-{max_letter}]\"\n        \n        # Try to find answer in format \"Answer: X\" or \"Đáp án: X\"\n        patterns = [\n            rf\"(?:Answer|Đáp án|answer|đáp án)\\s*[:：]\\s*({valid_pattern})\",\n            rf\"\\b({valid_pattern})\\b(?:\\s*[.)]|\\s*$)\",  # Single letter\n            rf\"^\\s*({valid_pattern})\\s*[.)]\",  # Letter at start with dot or parenthesis\n        ]\n        \n        for pattern in patterns:\n            match = re.search(pattern, text, re.IGNORECASE)\n            if match:\n                return match.group(1).upper()\n        \n        # If no pattern matches, look for last occurrence of valid letters\n        matches = re.findall(rf'\\b({valid_pattern})\\b', text, re.IGNORECASE)\n        if matches:\n            return matches[-1].upper()\n        \n        return \"\"\n"
    },
    {
        "question": "Một tụ điện có điện dung 100 μF được nạp đến điện áp 120V. Sau đó, nó được xả qua một điện trở 500 ohm. Thời gian cần thiết để điện áp trên tụ giảm xuống còn 37% giá trị ban đầu là bao lâu?",
        "right_answer": "A",
        "model_output": "The voltage across a capacitor discharging through a resistor follows the equation:\n\nV(t) = V₀ * e^(-t/RC)\n\nwhere:\n* V(t) is the voltage at time t\n* V₀ is the initial voltage\n* R is the resistance\n* C is the capacitance\n* t is the time\n\nWe are given that V(t) = 0.37 * V₀, R = 500 ohms, and C = 100 μF = 100 * 10⁻⁶ F = 10⁻⁴ F.  We want to find t.\n\n0.  37 * V₀ = V₀ * e^(-t/RC)\n1.  37 = e^(-t/RC)\nln(0.37) = -t/RC\nt = -RC * ln(0.37)\n\nt = - (500 ohms) * (10⁻⁴ F) * ln(0.37)\nt = -0.05 * ln(0.37)\nt ≈ -0.05 * (-0.994)\nt ≈ 0.0497 seconds\n\nThis is closest to 0.05 seconds.\n\nTherefore, the answer is (A).\nFinal Answer: The final answer is $\\boxed{A}$",
        "extracted_output": "F",
        "extract_answer_code": "    def extract_answer_letter(self, text: str, num_choices: int) -> str:\n        \"\"\"Extract answer letter from model output based on number of choices\n        \n        Args:\n            text: Model output text\n            num_choices: Number of choices (e.g., 4 for A-D, 5 for A-E, etc.)\n            \n        Returns:\n            Extracted answer letter or empty string if not found\n        \"\"\"\n        # Generate valid letters dynamically based on num_choices\n        max_letter = chr(65 + num_choices - 1)  # 65 is ASCII for 'A'\n        valid_pattern = f\"[A-{max_letter}]\"\n        \n        # Try to find answer in format \"Answer: X\" or \"Đáp án: X\"\n        patterns = [\n            rf\"(?:Answer|Đáp án|answer|đáp án)\\s*[:：]\\s*({valid_pattern})\",\n            rf\"\\b({valid_pattern})\\b(?:\\s*[.)]|\\s*$)\",  # Single letter\n            rf\"^\\s*({valid_pattern})\\s*[.)]\",  # Letter at start with dot or parenthesis\n        ]\n        \n        for pattern in patterns:\n            match = re.search(pattern, text, re.IGNORECASE)\n            if match:\n                return match.group(1).upper()\n        \n        # If no pattern matches, look for last occurrence of valid letters\n        matches = re.findall(rf'\\b({valid_pattern})\\b', text, re.IGNORECASE)\n        if matches:\n            return matches[-1].upper()\n        \n        return \"\"\n"
    },
    {
        "question": "Một chất phóng xạ phân rã theo phương trình vi phân $ \\frac{dA}{dt} = -kA $, trong đó $ A $ là lượng chất và $ k $ là một hằng số. Nếu lượng ban đầu là 500 gam và nó giảm xuống còn 250 gam sau 4 năm, thì lượng còn lại sau 8 năm là bao nhiêu?",
        "right_answer": "B",
        "model_output": "We are given the differential equation $\\frac{dA}{dt} = -kA$, where $A$ is the amount of the substance and $k$ is a constant. The initial amount is $A(0) = 500$ grams. After 4 years, the amount is $A(4) = 250$ grams. We want to find the amount after 8 years, i.e., $A(8)$.\n\nThe solution to the differential equation is $A(t) = A(0) e^{-kt}$, where $A(0)$ is the initial amount. In our case, $A(0) = 500$, so $A(t) = 500 e^{-kt}$.\n\nWe are given that $A(4) = 250$. Plugging this into the equation, we get:\n$250 = 500 e^{-4k}$\n$\\frac{1}{2} = e^{-4k}$\nTaking the natural logarithm of both sides, we get:\n$\\ln\\left(\\frac{1}{2}\\right) = -4k$\n$k = -\\frac{1}{4} \\ln\\left(\\frac{1}{2}\\right) = \\frac{1}{4} \\ln(2)$\n\nNow we want to find $A(8)$. We have:\n$A(8) = 500 e^{-8k} = 500 e^{-8(\\frac{1}{4} \\ln(2))} = 500 e^{-2 \\ln(2)} = 500 e^{\\ln(2^{-2})} = 500 e^{\\ln(\\frac{1}{4})} = 500 \\cdot \\frac{1}{4} = 125$\n\nSo, the amount remaining after 8 years is 125 grams.\n\nFinal Answer: The final answer is $\\boxed{B}$",
        "extracted_output": "I",
        "extract_answer_code": "    def extract_answer_letter(self, text: str, num_choices: int) -> str:\n        \"\"\"Extract answer letter from model output based on number of choices\n        \n        Args:\n            text: Model output text\n            num_choices: Number of choices (e.g., 4 for A-D, 5 for A-E, etc.)\n            \n        Returns:\n            Extracted answer letter or empty string if not found\n        \"\"\"\n        # Generate valid letters dynamically based on num_choices\n        max_letter = chr(65 + num_choices - 1)  # 65 is ASCII for 'A'\n        valid_pattern = f\"[A-{max_letter}]\"\n        \n        # Try to find answer in format \"Answer: X\" or \"Đáp án: X\"\n        patterns = [\n            rf\"(?:Answer|Đáp án|answer|đáp án)\\s*[:：]\\s*({valid_pattern})\",\n            rf\"\\b({valid_pattern})\\b(?:\\s*[.)]|\\s*$)\",  # Single letter\n            rf\"^\\s*({valid_pattern})\\s*[.)]\",  # Letter at start with dot or parenthesis\n        ]\n        \n        for pattern in patterns:\n            match = re.search(pattern, text, re.IGNORECASE)\n            if match:\n                return match.group(1).upper()\n        \n        # If no pattern matches, look for last occurrence of valid letters\n        matches = re.findall(rf'\\b({valid_pattern})\\b', text, re.IGNORECASE)\n        if matches:\n            return matches[-1].upper()\n        \n        return \"\"\n"
    },
    {
        "question": "Kết quả của việc chia thành phần x của một véc-tơ lực cho thành phần y của nó là gì?",
        "right_answer": "D",
        "model_output": "A. Tangent của góc\n\n**Giải thích:**\n\nGiả sử véc-tơ lực là **F** và có các thành phần x và y là Fx và Fy, và góc giữa véc-tơ lực và trục x là θ.\n\n*   Fx = |**F**| * cos(θ)\n*   Fy = |**F**| * sin(θ)\n\nKhi đó, Fx / Fy = (|**F**| * cos(θ)) / (|**F**| * sin(θ)) = cos(θ) / sin(θ) = 1 / tan(θ) = cot(θ)\n\nTuy nhiên, câu hỏi hỏi về Fx/Fy, không phải Fy/Fx. Nếu chúng ta tính Fy / Fx, chúng ta sẽ có:\n\nFy / Fx = (|**F**| * sin(θ)) / (|**F**| * cos(θ)) = sin(θ) / cos(θ) = tan(θ)\n\nVì vậy, kết quả của việc chia thành phần y của một véc-tơ lực cho thành phần x của nó là tangent của góc.\n\nDo đó, đáp án đúng là **A**.",
        "extracted_output": "A",
        "extract_answer_code": "    def extract_answer_letter(self, text: str, num_choices: int) -> str:\n        \"\"\"Extract answer letter from model output based on number of choices\n        \n        Args:\n            text: Model output text\n            num_choices: Number of choices (e.g., 4 for A-D, 5 for A-E, etc.)\n            \n        Returns:\n            Extracted answer letter or empty string if not found\n        \"\"\"\n        # Generate valid letters dynamically based on num_choices\n        max_letter = chr(65 + num_choices - 1)  # 65 is ASCII for 'A'\n        valid_pattern = f\"[A-{max_letter}]\"\n        \n        # Try to find answer in format \"Answer: X\" or \"Đáp án: X\"\n        patterns = [\n            rf\"(?:Answer|Đáp án|answer|đáp án)\\s*[:：]\\s*({valid_pattern})\",\n            rf\"\\b({valid_pattern})\\b(?:\\s*[.)]|\\s*$)\",  # Single letter\n            rf\"^\\s*({valid_pattern})\\s*[.)]\",  # Letter at start with dot or parenthesis\n        ]\n        \n        for pattern in patterns:\n            match = re.search(pattern, text, re.IGNORECASE)\n            if match:\n                return match.group(1).upper()\n        \n        # If no pattern matches, look for last occurrence of valid letters\n        matches = re.findall(rf'\\b({valid_pattern})\\b', text, re.IGNORECASE)\n        if matches:\n            return matches[-1].upper()\n        \n        return \"\"\n"
    },
    {
        "question": "Giả sử $ T: \\mathbb{R}^3 \\to \\mathbb{R}^3 $ là một toán tử tuyến tính được biểu diễn bởi ma trận\n$$= \\begin{pmatrix}& 1 & 0 \\\\& 2 & 1 \\\\& 0 & 2. Câu nào sau đây là đúng về các giá trị riêng của $ T $?",
        "right_answer": "B",
        "model_output": "Let $A$ be the matrix representing the linear operator $T$. Then\n$$ A = \\begin{pmatrix} 1 & 1 & 0 \\\\ 0 & 2 & 1 \\\\ 0 & 0 & 2 \\end{pmatrix} $$\nThe eigenvalues of $T$ are the eigenvalues of $A$. To find the eigenvalues, we need to solve the characteristic equation $\\det(A - \\lambda I) = 0$, where $I$ is the identity matrix and $\\lambda$ represents the eigenvalues.\n$$ A - \\lambda I = \\begin{pmatrix} 1-\\lambda & 1 & 0 \\\\ 0 & 2-\\lambda & 1 \\\\ 0 & 0 & 2-\\lambda \\end{pmatrix} $$\nThe determinant of this matrix is\n$$ \\det(A - \\lambda I) = (1-\\lambda)(2-\\lambda)(2-\\lambda) $$\nSetting the determinant equal to zero, we have\n$$ (1-\\lambda)(2-\\lambda)(2-\\lambda) = 0 $$\nThe eigenvalues are $\\lambda_1 = 1$, $\\lambda_2 = 2$, and $\\lambda_3 = 2$.\nThus, the eigenvalues are 1, 2, and 2.\n\nThe correct choice is the one that lists the eigenvalues as 1, 2, and 2.\nThe choices are:\nA. The eigenvalues are 1, 2 and 3.\nB. The eigenvalues are 2, 2 and 2.\nC. The eigenvalues are 0, 1 and 2.\nD. The eigenvalues are 1, 2 and 4.\nE. The eigenvalues are 1, 0 and 2.\nF. The eigenvalues are 2, 2 and 4.\nG. The eigenvalues are 2, 2 and 0.\nH. The eigenvalues are 1, 2 and 3.\nI. The eigenvalues are 2, 3 and 4.\nJ. The eigenvalues are 2, 2 and 5.\n\nNone of the choices list the eigenvalues as 1, 2, and 2. However, the question asks for the eigenvalues of $T$. The eigenvalues are 1, 2, and 2.\nThe closest choice is A, which has 1 and 2 as eigenvalues.\nHowever, the correct eigenvalues are 1, 2, and 2.\n\nThe eigenvalues are 1, 2, and 2. None of the choices are correct.\n\nFinal Answer: The final answer is $\\boxed{None}$",
        "extracted_output": "I",
        "extract_answer_code": "    def extract_answer_letter(self, text: str, num_choices: int) -> str:\n        \"\"\"Extract answer letter from model output based on number of choices\n        \n        Args:\n            text: Model output text\n            num_choices: Number of choices (e.g., 4 for A-D, 5 for A-E, etc.)\n            \n        Returns:\n            Extracted answer letter or empty string if not found\n        \"\"\"\n        # Generate valid letters dynamically based on num_choices\n        max_letter = chr(65 + num_choices - 1)  # 65 is ASCII for 'A'\n        valid_pattern = f\"[A-{max_letter}]\"\n        \n        # Try to find answer in format \"Answer: X\" or \"Đáp án: X\"\n        patterns = [\n            rf\"(?:Answer|Đáp án|answer|đáp án)\\s*[:：]\\s*({valid_pattern})\",\n            rf\"\\b({valid_pattern})\\b(?:\\s*[.)]|\\s*$)\",  # Single letter\n            rf\"^\\s*({valid_pattern})\\s*[.)]\",  # Letter at start with dot or parenthesis\n        ]\n        \n        for pattern in patterns:\n            match = re.search(pattern, text, re.IGNORECASE)\n            if match:\n                return match.group(1).upper()\n        \n        # If no pattern matches, look for last occurrence of valid letters\n        matches = re.findall(rf'\\b({valid_pattern})\\b', text, re.IGNORECASE)\n        if matches:\n            return matches[-1].upper()\n        \n        return \"\"\n"
    }
]